---
layout: clojure
head: Jark
---

h2. jark REPL

Now, launch a repl and write some clojure!

{% highlight bash %}
jark repl
jark [-h HOST -p PORT] repl
{% endhighlight %}

{% highlight bash %}
jark repl
user>> (defn add [x y] (let [s (+ x y)] (println s) s)) 
=> #'user/add
user>> (add 2 3)
5
=> 5
{% endhighlight %}

Notice that the REPL prints the returned value, prefixed by '=>'.

h3. REPL Commands

REPL command is a cool feature. Below is the complete list of REPL commands:

<pre class="terminal"><code>REPL Commands:
/clear
/cp [list add]
/debug [true false]
/inspect var
/ns namespace
/readline [true false]
/server [version info]
/vm [info stat]
</code></pre>

Switch on/off the nREPL debug-mode

{% highlight bash %}
user>> /debug on
debug is ON
user>> (+ 2 2)
put : (+ 2 2)
got : {'status': 'done', 'ns': 'user', 'id': 'localhost:9000-repl', 'value': '4\n'}
4
user>> /debug off
{% endhighlight %}

h3. REPL keyboard shortucts

*Line edit (emacs-style)*

|Kill-line|C-k|
|backward-char|C-b|
|backward-delete-char|C-h|
|backword-word|M-b|
|beginning-of-line|C-a|
|capitalize-word|M-c|
|clear|C-l|
|delete-char-or-end-of-file|C-d|
|downcase-word|M-l|
|end-of-line|C-e|
|forward-char|C-f|
|forward-word|M-f|
|interrupt|C-c|
|kill-word|M-d|
|transpose-chars|C-t|
|unix-line-discard|C-u|
|yank|C-y|

*History*

|beginning-of-history|M-<|
|end-of-history|M->|
|next-history|C-n|
|previous-history|C-p|
|reverse-search-history|C-r|

*Completions*

|Complete-file-name|C-i|

Caveat: The jark REPL does not work on Windows, yet.
